参考：

1、GOMAXPROCS需要设置吗？
https://colobu.com/2017/10/11/interesting-things-about-GOMAXPROCS/
	-p n
		the number of programs, such as build commands or
		test binaries, that can be run in parallel.
		The default is GOMAXPROCS, normally the number of CPUs available.

2、golang中的race检测
https://www.cnblogs.com/yjf512/p/5144211.html
	-race
		enable data race detection.
		Supported only on linux/amd64, freebsd/amd64, darwin/amd64, darwin/arm64, windows/amd64,
		linux/ppc64le and linux/arm64 (only for 48-bit VMA).

3、
	-msan
		enable interoperation with memory sanitizer.
		Supported only on linux/amd64, linux/arm64
		and only with Clang/LLVM as the host C compiler.
		On linux/arm64, pie build mode will be used.

4、
	-asan
		enable interoperation with address sanitizer.
		Supported only on linux/arm64, linux/amd64.

5、
	-asmflags '[pattern=]arg list'
		arguments to pass on each go tool asm invocation.

	-gcflags '[pattern=]arg list'
		arguments to pass on each go tool compile invocation.

	-ldflags '[pattern=]arg list'
		arguments to pass on each go tool link invocation.

6、
	-buildvcs
		Whether to stamp binaries with version control information. By default,
		version control information is stamped into a binary if the main package
		and the main module containing it are in the repository containing the
		current directory (if there is a repository). Use -buildvcs=false to
		omit version control information.
		是否用版本控制信息标记二进制文件。 默认情况下，
		如果主包，则版本控制信息被标记为二进制文件
		以及包含它的主模块在包含
		当前目录（如果有存储库）。 使用 -buildvcs=false 来
		省略版本控制信息。

7、
	-gccgoflags '[pattern=]arg list'
		arguments to pass on each gccgo compiler/linker invocation.

8、
	-installsuffix suffix
		a suffix to use in the name of the package installation directory,
		in order to keep output separate from default builds.
		If using the -race flag, the install suffix is automatically set to race
		or, if set explicitly, has _race appended to it. Likewise for the -msan
		and -asan flags. Using a -buildmode option that requires non-default compile
		flags has a similar effect.
		在包安装目录的名称中使用的后缀，
		为了使输出与默认构建分开。
		如果使用 -race 标志，安装后缀会自动设置为 race
		或者，如果明确设置，则附加 _race。 同样对于 -msan
		和 -asan 标志。 使用需要非默认编译的 -buildmode 选项
		标志具有类似的效果。

9、
	-linkshared
		build code that will be linked against shared libraries previously
		created with -buildmode=shared.
		构建之前将链接到共享库的代码
		使用 -buildmode=shared 创建。

10、
	-mod mode
		module download mode to use: readonly, vendor, or mod.
		By default, if a vendor directory is present and the go version in go.mod
		is 1.14 or higher, the go command acts as if -mod=vendor were set.
		Otherwise, the go command acts as if -mod=readonly were set.
		See https://golang.org/ref/mod#build-commands for details.
		要使用的模块下载模式：readonly、vendor 或 mod。
		默认情况下，如果存在供应商目录并且 go.mod 中的 go 版本
		是 1.14 或更高版本，go 命令就像设置了 -mod=vendor 一样。
		否则，go 命令就像设置了 -mod=readonly 一样。
		有关详细信息，请参阅 https://golang.org/ref/mod#build-commands。

11、
	-modcacherw
		leave newly-created directories in the module cache read-write
		instead of making them read-only.
		将新创建的目录留在模块缓存中读写
		而不是将它们设为只读。

12、
	-modfile file
		in module aware mode, read (and possibly write) an alternate go.mod
		file instead of the one in the module root directory. A file named
		"go.mod" must still be present in order to determine the module root
		directory, but it is not accessed. When -modfile is specified, an
		alternate go.sum file is also used: its path is derived from the
		-modfile flag by trimming the ".mod" extension and appending ".sum".
		在模块感知模式下，读取（并可能写入）备用 go.mod
		文件而不是模块根目录中的文件。 一个名为
		“go.mod”必须仍然存在才能确定模块根
		目录，但未访问。 当指定 -modfile 时，一个
		还使用了备用 go.sum 文件：它的路径来自
		-modfile 标志，通过修剪“.mod”扩展名并附加“.sum”。

13、
	-overlay file
		read a JSON config file that provides an overlay for build operations.
		The file is a JSON struct with a single field, named 'Replace', that
		maps each disk file path (a string) to its backing file path, so that
		a build will run as if the disk file path exists with the contents
		given by the backing file paths, or as if the disk file path does not
		exist if its backing file path is empty. Support for the -overlay flag
		has some limitations: importantly, cgo files included from outside the
		include path must be in the same directory as the Go package they are
		included from, and overlays will not appear when binaries and tests are
		run through go run and go test respectively.
		读取为构建操作提供覆盖的 JSON 配置文件。
		该文件是一个具有单个字段的 JSON 结构，名为“Replace”，即
		将每个磁盘文件路径（一个字符串）映射到其后备文件路径，以便
		构建将运行，就好像磁盘文件路径与内容存在一样
		由后备文件路径给出，或者好像磁盘文件路径没有
		如果其后备文件路径为空，则存在。 支持 -overlay 标志
		有一些限制：重要的是，从外部包含的 cgo 文件
		include路径必须和他们所在的Go包在同一个目录
		包含自，并且当二进制文件和测试被包含时，覆盖将不会出现
		分别运行go run和go test。

14、
	-pkgdir dir
		install and load all packages from dir instead of the usual locations.
		For example, when building with a non-standard configuration,
		use -pkgdir to keep generated packages in a separate location.
		从目录而不是通常的位置安装和加载所有包。
		例如，在使用非标准配置构建时，
		使用 -pkgdir 将生成的包保存在单独的位置。


15、
go build -tags 的使用
https://www.cnblogs.com/linyihai/p/10859945.html
https://zhuanlan.zhihu.com/p/269746831
	-tags tag,list
		a comma-separated list of build tags to consider satisfied during the
		build. For more information about build tags, see the description of
		build constraints in the documentation for the go/build package.
		(Earlier versions of Go used a space-separated list, and that form
		is deprecated but still recognized.)
		逗号分隔的构建标签列表，在构建过程中考虑满足
		建造。 有关构建标签的更多信息，请参阅
		在 go/build 包的文档中构建约束。
		（Go 的早期版本使用空格分隔的列表，并且这种形式
		已弃用但仍被认可。）

16、
	-trimpath
		remove all file system paths from the resulting executable.
		Instead of absolute file system paths, the recorded file names
		will begin either a module path@version (when using modules),
		or a plain import path (when using the standard library, or GOPATH).
		从生成的可执行文件中删除所有文件系统路径。
		而不是绝对文件系统路径，记录的文件名
		将开始模块路径@版本（使用模块时），
		或普通导入路径（使用标准库或 GOPATH 时）。

17、
	-toolexec 'cmd args'
		a program to use to invoke toolchain programs like vet and asm.
		For example, instead of running asm, the go command will run
		'cmd args /path/to/asm <arguments for asm>'.
		The TOOLEXEC_IMPORTPATH environment variable will be set,
		matching 'go list -f {{.ImportPath}}' for the package being built.
		用于调用工具链程序（如 vet 和 asm）的程序。
		例如，不是运行 asm，而是运行 go 命令
		'cmd args /path/to/asm <asm 的参数>'。
		将设置 TOOLEXEC_IMPORTPATH 环境变量，
		为正在构建的包匹配 'go list -f {{.ImportPath}}'。







$ go version
go version go1.18.1 darwin/amd64


$ go help build
usage: go build [-o output] [build flags] [packages]

Build compiles the packages named by the import paths,
along with their dependencies, but it does not install the results.
Build 编译由导入路径命名的包，
连同它们的依赖项，但它不会安装结果。

If the arguments to build are a list of .go files from a single directory,
build treats them as a list of source files specifying a single package.
如果构建的参数是单个目录中的 .go 文件列表，
build 将它们视为指定单个包的源文件列表。

When compiling packages, build ignores files that end in '_test.go'.

When compiling a single main package, build writes
the resulting executable to an output file named after
the first source file ('go build ed.go rx.go' writes 'ed' or 'ed.exe')
or the source code directory ('go build unix/sam' writes 'sam' or 'sam.exe').
The '.exe' suffix is added when writing a Windows executable.
编译单个主包时，构建写入
生成的可执行文件到以其命名的输出文件
第一个源文件（'go build ed.go rx.go' 写入 'ed' 或 'ed.exe'）
或源代码目录（“go build unix/sam”写入“sam”或“sam.exe”）。
编写 Windows 可执行文件时会添加“.exe”后缀。

When compiling multiple packages or a single non-main package,
build compiles the packages but discards the resulting object,
serving only as a check that the packages can be built.
编译多个包或单个非主包时，
build 编译包但丢弃生成的对象，
仅用作检查是否可以构建包。

The -o flag forces build to write the resulting executable or object
to the named output file or directory, instead of the default behavior described
in the last two paragraphs. If the named output is an existing directory or
ends with a slash or backslash, then any resulting executables
will be written to that directory.
-o 标志强制构建写入生成的可执行文件或对象
到指定的输出文件或目录，而不是描述的默认行为
在最后两段中。 如果命名输出是现有目录或
以斜杠或反斜杠结尾，然后是任何生成的可执行文件
将写入该目录。

The -i flag installs the packages that are dependencies of the target.
The -i flag is deprecated. Compiled packages are cached automatically.
-i 标志安装作为目标依赖项的包。
-i 标志已弃用。 编译的包会自动缓存。

The build flags are shared by the build, clean, get, install, list, run,
and test commands:

	-a
		force rebuilding of packages that are already up-to-date.
		强制重建已经是最新的包。

	-n
		print the commands but do not run them.

	-p n
		the number of programs, such as build commands or
		test binaries, that can be run in parallel.
		The default is GOMAXPROCS, normally the number of CPUs available.

	-race
		enable data race detection.
		Supported only on linux/amd64, freebsd/amd64, darwin/amd64, darwin/arm64, windows/amd64,
		linux/ppc64le and linux/arm64 (only for 48-bit VMA).

	-msan
		enable interoperation with memory sanitizer.
		Supported only on linux/amd64, linux/arm64
		and only with Clang/LLVM as the host C compiler.
		On linux/arm64, pie build mode will be used.

	-asan
		enable interoperation with address sanitizer.
		Supported only on linux/arm64, linux/amd64.

	-v
		print the names of packages as they are compiled.

	-work
		print the name of the temporary work directory and
		do not delete it when exiting.

	-x
		print the commands.

	-asmflags '[pattern=]arg list'
		arguments to pass on each go tool asm invocation.

	-buildmode mode
		build mode to use. See 'go help buildmode' for more.

	-buildvcs
		Whether to stamp binaries with version control information. By default,
		version control information is stamped into a binary if the main package
		and the main module containing it are in the repository containing the
		current directory (if there is a repository). Use -buildvcs=false to
		omit version control information.
		是否用版本控制信息标记二进制文件。 默认情况下，
		如果主包，则版本控制信息被标记为二进制文件
		以及包含它的主模块在包含
		当前目录（如果有存储库）。 使用 -buildvcs=false 来
		省略版本控制信息。

	-compiler name
		name of compiler to use, as in runtime.Compiler (gccgo or gc).

	-gccgoflags '[pattern=]arg list'
		arguments to pass on each gccgo compiler/linker invocation.

	-gcflags '[pattern=]arg list'
		arguments to pass on each go tool compile invocation.

	-installsuffix suffix
		a suffix to use in the name of the package installation directory,
		in order to keep output separate from default builds.
		If using the -race flag, the install suffix is automatically set to race
		or, if set explicitly, has _race appended to it. Likewise for the -msan
		and -asan flags. Using a -buildmode option that requires non-default compile
		flags has a similar effect.
		在包安装目录的名称中使用的后缀，
		为了使输出与默认构建分开。
		如果使用 -race 标志，安装后缀会自动设置为 race
		或者，如果明确设置，则附加 _race。 同样对于 -msan
		和 -asan 标志。 使用需要非默认编译的 -buildmode 选项
		标志具有类似的效果。

	-ldflags '[pattern=]arg list'
		arguments to pass on each go tool link invocation.

	-linkshared
		build code that will be linked against shared libraries previously
		created with -buildmode=shared.
		构建之前将链接到共享库的代码
		使用 -buildmode=shared 创建。

	-mod mode
		module download mode to use: readonly, vendor, or mod.
		By default, if a vendor directory is present and the go version in go.mod
		is 1.14 or higher, the go command acts as if -mod=vendor were set.
		Otherwise, the go command acts as if -mod=readonly were set.
		See https://golang.org/ref/mod#build-commands for details.
		要使用的模块下载模式：readonly、vendor 或 mod。
		默认情况下，如果存在供应商目录并且 go.mod 中的 go 版本
		是 1.14 或更高版本，go 命令就像设置了 -mod=vendor 一样。
		否则，go 命令就像设置了 -mod=readonly 一样。
		有关详细信息，请参阅 https://golang.org/ref/mod#build-commands。

	-modcacherw
		leave newly-created directories in the module cache read-write
		instead of making them read-only.
		将新创建的目录留在模块缓存中读写
		而不是将它们设为只读。

	-modfile file
		in module aware mode, read (and possibly write) an alternate go.mod
		file instead of the one in the module root directory. A file named
		"go.mod" must still be present in order to determine the module root
		directory, but it is not accessed. When -modfile is specified, an
		alternate go.sum file is also used: its path is derived from the
		-modfile flag by trimming the ".mod" extension and appending ".sum".
		在模块感知模式下，读取（并可能写入）备用 go.mod
		文件而不是模块根目录中的文件。 一个名为
		“go.mod”必须仍然存在才能确定模块根
		目录，但未访问。 当指定 -modfile 时，一个
		还使用了备用 go.sum 文件：它的路径来自
		-modfile 标志，通过修剪“.mod”扩展名并附加“.sum”。

	-overlay file
		read a JSON config file that provides an overlay for build operations.
		The file is a JSON struct with a single field, named 'Replace', that
		maps each disk file path (a string) to its backing file path, so that
		a build will run as if the disk file path exists with the contents
		given by the backing file paths, or as if the disk file path does not
		exist if its backing file path is empty. Support for the -overlay flag
		has some limitations: importantly, cgo files included from outside the
		include path must be in the same directory as the Go package they are
		included from, and overlays will not appear when binaries and tests are
		run through go run and go test respectively.
		读取为构建操作提供覆盖的 JSON 配置文件。
		该文件是一个具有单个字段的 JSON 结构，名为“Replace”，即
		将每个磁盘文件路径（一个字符串）映射到其后备文件路径，以便
		构建将运行，就好像磁盘文件路径与内容存在一样
		由后备文件路径给出，或者好像磁盘文件路径没有
		如果其后备文件路径为空，则存在。 支持 -overlay 标志
		有一些限制：重要的是，从外部包含的 cgo 文件
		include路径必须和他们所在的Go包在同一个目录
		包含自，并且当二进制文件和测试被包含时，覆盖将不会出现
		分别运行go run和go test。

	-pkgdir dir
		install and load all packages from dir instead of the usual locations.
		For example, when building with a non-standard configuration,
		use -pkgdir to keep generated packages in a separate location.
		从目录而不是通常的位置安装和加载所有包。
		例如，在使用非标准配置构建时，
		使用 -pkgdir 将生成的包保存在单独的位置。

	-tags tag,list
		a comma-separated list of build tags to consider satisfied during the
		build. For more information about build tags, see the description of
		build constraints in the documentation for the go/build package.
		(Earlier versions of Go used a space-separated list, and that form
		is deprecated but still recognized.)
		逗号分隔的构建标签列表，在构建过程中考虑满足
		建造。 有关构建标签的更多信息，请参阅
		在 go/build 包的文档中构建约束。
		（Go 的早期版本使用空格分隔的列表，并且这种形式
		已弃用但仍被认可。）

	-trimpath
		remove all file system paths from the resulting executable.
		Instead of absolute file system paths, the recorded file names
		will begin either a module path@version (when using modules),
		or a plain import path (when using the standard library, or GOPATH).
		从生成的可执行文件中删除所有文件系统路径。
		而不是绝对文件系统路径，记录的文件名
		将开始模块路径@版本（使用模块时），
		或普通导入路径（使用标准库或 GOPATH 时）。

	-toolexec 'cmd args'
		a program to use to invoke toolchain programs like vet and asm.
		For example, instead of running asm, the go command will run
		'cmd args /path/to/asm <arguments for asm>'.
		The TOOLEXEC_IMPORTPATH environment variable will be set,
		matching 'go list -f {{.ImportPath}}' for the package being built.
		用于调用工具链程序（如 vet 和 asm）的程序。
		例如，不是运行 asm，而是运行 go 命令
		'cmd args /path/to/asm <asm 的参数>'。
		将设置 TOOLEXEC_IMPORTPATH 环境变量，
		为正在构建的包匹配 'go list -f {{.ImportPath}}'。

The -asmflags, -gccgoflags, -gcflags, and -ldflags flags accept a
space-separated list of arguments to pass to an underlying tool
during the build. To embed spaces in an element in the list, surround
it with either single or double quotes. The argument list may be
preceded by a package pattern and an equal sign, which restricts
the use of that argument list to the building of packages matching
that pattern (see 'go help packages' for a description of package
patterns). Without a pattern, the argument list applies only to the
packages named on the command line. The flags may be repeated
with different patterns in order to specify different arguments for
different sets of packages. If a package matches patterns given in
multiple flags, the latest match on the command line wins.
For example, 'go build -gcflags=-S fmt' prints the disassembly
only for package fmt, while 'go build -gcflags=all=-S fmt'
prints the disassembly for fmt and all its dependencies.
-asmflags、-gccgoflags、-gcflags 和 -ldflags 标志接受一个
要传递给基础工具的以空格分隔的参数列表
在构建过程中。 要在列表中的元素中嵌入空格，请将空格包围
它带有单引号或双引号。 参数列表可能是
前面是包模式和等号，它限制
使用该参数列表来构建匹配的包
该模式（请参阅“go help packages”以获取包的描述
模式）。 没有模式，参数列表仅适用于
在命令行上命名的包。 标志可能会重复
用不同的模式来指定不同的参数
不同的套餐。 如果一个包匹配给定的模式
多个标志，命令行上的最新匹配项获胜。
例如，'go build -gcflags=-S fmt' 打印反汇编
仅适用于包 fmt，而 'go build -gcflags=all=-S fmt'
打印 fmt 及其所有依赖项的反汇编。

For more about specifying packages, see 'go help packages'.
For more about where packages and binaries are installed,
run 'go help gopath'.
For more about calling between Go and C/C++, run 'go help c'.

Note: Build adheres to certain conventions such as those described
by 'go help gopath'. Not all projects can follow these conventions,
however. Installations that have their own conventions or that use
a separate software build system may choose to use lower-level
invocations such as 'go tool compile' and 'go tool link' to avoid
some of the overheads and design decisions of the build tool.
注意：构建遵循某些约定，例如所描述的约定
通过'去帮助gopath'。 并非所有项目都可以遵循这些约定，
然而。 有自己的约定或使用的安装
一个单独的软件构建系统可以选择使用较低级别
避免诸如“go tool compile”和“go tool link”之类的调用
构建工具的一些开销和设计决策。

See also: go install, go get, go clean.

